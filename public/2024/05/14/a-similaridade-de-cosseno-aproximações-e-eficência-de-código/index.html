<!DOCTYPE html>
<html lang="en-US">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=4321&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.126.0">


<title>A similaridade de cosseno, aproximações e eficência de código - Blog do Bruno</title>
<meta property="og:title" content="A similaridade de cosseno, aproximações e eficência de código - Blog do Bruno">


  <link href='//localhost:4321/favicon.ico' rel='icon' type='image/x-icon'/>



  








<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/profile_pic.jpeg"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="https://github.com/brunoritter">GitHub</a></li>
    
    <li><a href="https://www.linkedin.com/in/bruno-ritter-1002868a/">LinkedIn</a></li>
    
    <li><a href="/about/">Sobre mim</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">10 min read</span>
    

    <h1 class="article-title">A similaridade de cosseno, aproximações e eficência de código</h1>

    
    <span class="article-date">2024-05-14</span>
    

    <div class="article-content">
      
      <h1 id="introdução">Introdução</h1>
<p>Neste blog, exploramos a aplicação da similaridade de cosseno para calcular distâncias entre pontos geográficos, utilizando uma aproximação esférica da Terra. Embora tenhamos simplificado a forma da Terra para um esferoide perfeito, os resultados demonstraram que essa abordagem introduz erros mínimos, tornando-a uma alternativa viável e eficiente para cálculos de distâncias em grande escala.</p>
<p>Ao compararmos o método da similaridade de cosseno com a solução mais precisa do <em>geopy</em>, observamos que a diferença nas distâncias calculadas foi insignificante para a maioria das aplicações práticas, com um erro médio de apenas 0.2%. Além disso, a eficiência do nosso método foi surpreendente: ele foi mais de 2300 vezes mais rápido que o método preciso, o que se torna crucial quando lidamos com grandes volumes de dados.</p>
<p>Esse exercício, além de demonstrar como a distância de cosseno é idealizada e calculada, ilustra como um bom entendimento do problema pode levar a soluções altamente eficientes e suficientemente precisas para problemas complexos em ciência de dados.</p>
<p>Espero que as técnicas e conceitos discutidos aqui possam ser úteis em suas próprias explorações e desafios de data science :)</p>
<h1 id="o-desafio">O desafio</h1>
<p>Depois de um tempo completamente dedicado à estudar matemática como os antigos faziam (lapiseira e papel), e usando python majoritariamente para fins astrofísicos, resolvi procurar alguns desafios relacionados a dados para exercitar um pouco o ferramental mais utilizado na prática da ciência de dados, como pandas, matplotlib e scikit-learn. Pesquisando no <a href="https://www.reddit.com/r/datascience/">r/datascience</a>, vi um colega indicando os desafios do <a href="https://data-puzzles.com/">data-puzzles</a>.</p>
<p>Um dos primeiros desafios é o <a href="https://data-puzzles.com/challenges/travel-planner/">travel planer</a>, com a tag ‘feature engineering’. Considero que essa é uma das habilidades mais relevantes para um cientista de dados. A máxima “garbage in, garbage out” é repetida exaustivamente por uma razão: modelos simples com as features corretas podem operar milagres. O desafio te entrega uma base de dados com as coordenadas geográficas (latitude e longitude) de todas as capitais nacionais do mundo, e um objetivo simples: encontrar as duas capitais com a maior distância possível entre elas, considerando uma trajetória na superfície terrestre.</p>
<p>O código abaixo carrega a base de dados e exibe as 5 primeiras linhas.</p>
<pre><code class="language-python">import pandas as pd

capitals_df = pd.read_csv('https://raw.githubusercontent.com/hyperc54/data-puzzles-assets/master/features/travel/worldcapitals_light.csv')
print(capitals_df.shape)
</code></pre>
<p>(249, 3)</p>
<pre><code class="language-python">print(capitals_df.head().to_markdown())
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:left">city</th>
<th style="text-align:right">lat</th>
<th style="text-align:right">lng</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">0</td>
<td style="text-align:left">Tokyo</td>
<td style="text-align:right">35.6839</td>
<td style="text-align:right">139.774</td>
</tr>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:left">Jakarta</td>
<td style="text-align:right">-6.2146</td>
<td style="text-align:right">106.845</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:left">Manila</td>
<td style="text-align:right">14.6</td>
<td style="text-align:right">120.983</td>
</tr>
<tr>
<td style="text-align:right">3</td>
<td style="text-align:left">Seoul</td>
<td style="text-align:right">37.56</td>
<td style="text-align:right">126.99</td>
</tr>
<tr>
<td style="text-align:right">4</td>
<td style="text-align:left">Mexico City</td>
<td style="text-align:right">19.4333</td>
<td style="text-align:right">-99.1333</td>
</tr>
</tbody>
</table>
<p>Para encontrar a melhor estratégia de solução, vamos fazer algumas considerações geométricas. Sabemos que a Terra não é exatamente uma esfera. A rotação do planeta faz com que ele seja achatado nos polos e alongado no equador, formando o que chamamos de um “esferóide oblato”.</p>
<div style="text-align: center;">
  <img src="/images/tipos-de-esferoides.jpg" alt="tipos de esferóides"/>
  <p style="font-size: 0.8em; color: gray; margin-top: 5px;">
    A imagem mostra lado a lado um esferóide oblato (formato aproximado da Terra), um esferóide prolato (no qual o achatamento ocorre no equador, e o alongamento nos polos), e uma esfera. Peguei a imagem <a href="https://andydx.com/descubrimientos/la-verdadera-forma-de-la-tierra/">aqui</a>.
  </p>
</div>
<p>No entanto, seria extremamente vantajoso tratar este problema assumindo que a Terra é perfeitamente esférica. Isso nos permitiria utilizar a métrica de similaridade de cosseno para medir distâncias, simplificando alguns cálculos que seriam necessários para refletir a variação do raio terreste. Sabendo as dimensões dos eixos do esferóide oblato correspondente às dimensões terrestres, podemos calcular o nível de achatamento do esferóide com a seguinte equação:</p>
<p>$$
f\ =\ \frac{a-b}{a}
$$
Onde <code>\(\mathbf{a}\)</code> é o raio equatorial (6.378Km), e <code>\(\mathbf{b}\)</code> é o raio polar (6.357Km). Substituindo os valores, calculamos <code>\(\mathbf{f} = 0.0034\)</code>. Esse valor é muito pequeno, e indica que a diferença entre o eixo maior e o menor é de aproximadamente 1 parte em 298.257. Considero seguro seguirmos em frente com a aproximação esférica e o uso da similaridade de cosseno.</p>
<p>Vamos conferir os detalhes desta métrica.</p>
<h1 id="a-similaridade-de-cosseno">A similaridade de cosseno</h1>
<p>A similaridade de cosseno é amplamente utilizada em ciência de dados. Algumas das suas aplicações mais importantes incluem: algoritmos de clusterização (como K-means e K-NN), sistemas de recomendação (filtragem colaborativa) e embeddings de palavras e sentenças em modelos de linguagem de grande escala (LLMs).</p>
<p>A aplicação geográfica que estamos fazendo é uma demonstração muito didática da motivação da similaridade de cosseno. A partir do centro do planeta Terra, traçamos uma linha reta até a posição de uma capital qualquer (vamos chamar de capital A). Esta linha é o vetor posição <code>\(\mathbf{p}_1\)</code>. Fazemos o mesmo procedimento para uma segunda capital (Capital B) para encontrar o vetor <code>\(\mathbf{p}_2\)</code>. O ângulo <code>\(\theta\)</code> entre os vetores <code>\(\mathbf{p}_1\)</code> e <code>\(\mathbf{p}_2\)</code> é proporcional à distância na superfície terrestre entre as capitais. O cosseno deste ângulo é a similaridade cosseno entre os vetores.</p>
<div style="text-align: center;">
<img src="/images/cos_dist-1.png" alt="similaridade cosseno" width=300/>
<p style="font-size: 0.8em; color: gray; margin-top: 5px;">O ângulo entre duas capitais.</p>
</div>
<p>Enquanto nessa aplicação nossos vetores possuem 3 dimensões que representam as dimensões espaciais, em uma aplicação de clusterização cada dimensão dos vetores representaria uma característica dos objetos sendo agrupados (usários de um app, por exemplo). Em uma aplicação para NLP, o espaço seria composto pelas <code>\(\mathbf{n}\)</code> dimensões do word embedding, representando características latentes que capturam significados semânticos das palavras.</p>
<p>O <em>scipy</em> já possui uma função para computar o cosseno entre vetores (experimente usar <code>from scipy.spatial.distance import cosine</code>). Mas pelo bem da educação, vamos implementar o cálculo &ldquo;do zero&rdquo;. Matematicamente, podemos partir da definição do produto interno entre dois vetores:</p>
<p>$$
\cos(\theta) = \frac{\mathbf{p}_1 \cdot \mathbf{p}_2}{|\mathbf{p}_1| |\mathbf{p}_2|}
$$
Ou seja, para encontrar a similaridade de cosseno entre dois vetores, calculamos o produto interno entre eles, e dividimos pelo produto dos seus módulos.</p>
<h1 id="implementação-do-cálculo-da-similaridade-de-cosseno">Implementação do cálculo da similaridade de cosseno</h1>
<p>Podemos usar um pouco de trigonometria para descrever os nossos vetores de posição - originalmente descritos em coordenadas esféricas - em termos das 3 coordenadas espaciais cartesianas (<em>x,y</em> e <em>z</em>). O diagrama abaixo mostra como os senos e cossenos dos ângulos que dão as coordenadas esféricas podem ser utilizados para fazer a transformação.</p>
<div style="text-align: center;">
<img src="/images/polar_to_cartesian.png" alt="coordenadas polares para cartesianas"  width=300/>
<p style="font-size: 0.8em; color: gray; margin-top: 5px;">
    A relação entre coordenadas esféricas e coordenadas cartesianas. Peguei a imagem <a             href="https://www.researchgate.net/figure/Visualization-of-coordinates-in-both-cartesian-and-spherical-systems_fig2_303542946">aqui</a>.
  </p>
</div>
<p>Usamos o numpy para fazer as operações:</p>
<pre><code class="language-python">import numpy as np

# Converte os ângulos para radianos
capitals_df['lat_radians'] = np.radians(capitals_df['lat'])
capitals_df['lng_radians'] = np.radians(capitals_df['lng'])

# Usa as relações demonstradas no diagrama acima para encontrar as coordenadas cartesianas
capitals_df['x'] = np.cos(capitals_df['lat_radians']) * np.cos(capitals_df['lng_radians'])
capitals_df['y'] = np.cos(capitals_df['lat_radians']) * np.sin(capitals_df['lng_radians'])
capitals_df['z'] = np.sin(capitals_df['lat_radians'])
</code></pre>
<p>Perceba que, ao fazer essas transformações, os vetores são normalizados. Na prática, isso significa que podemos simplificar o cálculo da distância para <code>\(\cos(\theta) = \mathbf{p}_1 \cdot \mathbf{p}_2\)</code>. Precisamos calcular o produto interno entre todos os vetores posição das nossas capitais. Felizmente, a àlgebra linear está a nosso favor. Se agregarmos todos os vetores posição em uma matriz, basta multiplicá-la pela sua transposta para obter os produtos internos. O numpy segue sendo a ferramenta adequada:</p>
<pre><code class="language-python"># Cria matriz de vetores de posição
matrix = capitals_df[['x', 'y', 'z']].to_numpy()

# Calcula cosseno entre vetores
cos = np.clip(np.dot(matrix, matrix.T), -1, 1) 
</code></pre>
<p>Com os ângulos calculados, é simples de encontrar as distâncias, considerando que as trajetórias são os arcos que conectam os vetores, que possuem módulos constantes iguais ao raio da Terra (na nossa aproximação esférica). Vamos considerar que o raio da nossa Terra redonda é o ponto médio entre o raio polar e o raio equatorial.</p>
<pre><code class="language-python"># Calcula raio da Terra redonda
min_earth_r = 6357
max_earth_r = 6378
mid_earth_r = (min_earth_r+max_earth_r)/2

# Computa os tamanhos dos arcos em Km
theta = np.arccos(cos)
pairwise_distances = (theta * mid_earth_r)
</code></pre>
<p>Pronto! Tudo calculado. Para encontrar a resposta do quiz (os nomes das duas capitais com maior distância entre si), buscamos os índices da maior distância armazenada nessa matriz.</p>
<pre><code class="language-python"># Encontra e armazena os índíces das duas capitais mais distantes, assim como o módulo da separação entre elas 
max_distance = np.amax(pairwise_distances)
city_indexes = np.unravel_index(np.argmax(theta), theta.shape)
city_a = capitals_df['city'][city_indexes[0]]
city_b = capitals_df['city'][city_indexes[1]]

# Imprime o resultado
print(f&quot;As capitais mais distantes são {city_a} e {city_b}, com uma separação de {np.round(max_distance, 1)} Km&quot;)
</code></pre>
<p>As capitais mais distantes são Manama e Adamstown, com uma separação de 19859.3 Km</p>
<p>Agora podemos conferir o gabarito e colocar nossa aproximação esférica a prova. Foi ou não uma boa aproximação? O site tem um notebook com uma solução diferente implementada. Vamos ver.</p>
<h1 id="o-nosso-método-vs-o-método-correto">O nosso método VS o &ldquo;método correto&rdquo;</h1>
<p>A solução do gabarito usa um método mais preciso para calcular as distâncias, disponível na função <em>distance</em> do <em>geopy</em>. E, em contraste com a operação matricial que demonstrei, faz um loop duplo por todas as linhas do dataset, extraindo os valores de latitude e longitude e os utilizando como input para a a função do <em>geopy</em>.</p>
<pre><code class="language-python">from geopy import distance

geopy_pairwise_distances = np.empty([capitals_df.shape[0], capitals_df.shape[0]])

# Fill in the blanks, fortunately, there's 'only' &lt;300 capitals!
for i in range(capitals_df.shape[0]):
    for j in range(capitals_df.shape[0]):
        lat_i = capitals_df.iloc[i]['lat']
        lng_i = capitals_df.iloc[i]['lng']
        lat_j = capitals_df.iloc[j]['lat']
        lng_j = capitals_df.iloc[j]['lng']

        geopy_pairwise_distances[i][j] = distance.distance(
            (lat_i, lng_i),
            (lat_j, lng_j)
        ).km

# Retrieve maximum value
geopy_max_distance = np.amax(geopy_pairwise_distances)

# Retrive indices of the element(s)
max_elements_indices = np.where(geopy_pairwise_distances == geopy_max_distance)

i_city1_max, i_city2_max = max_elements_indices[0]

city1_max = capitals_df.iloc[i_city1_max].city
city2_max = capitals_df.iloc[i_city2_max].city

print(f&quot;As capitais mais distantes são {city1_max} e {city2_max}, com uma separação de {np.round(geopy_max_distance, 1)} Km&quot;)
</code></pre>
<p>As capitais mais distantes são Doha e Adamstown, com uma separação de 19865.5 Km</p>
<p>Hm, erramos.</p>
<p>Mas temos algumas coisas interessantes acontecendo.</p>
<p>Primeiro, note que Adamstown faz parte do par nos dois métodos, e que as maiores distâncias encontradas por cada método diferem em menos de 10Km. Dada a ordem de grandeza das distâncias medidas, e considerando que a extensão espacial de uma capital costuma ser maior do que 10Km, na prática, podemos dizer que essa diferença é insignificante. Para a maior parte das aplicações, um modelo que usa como feature a distância entre locais na superfície do globo não deve apresentar diferenças significativas se as distâncias forem calculas por um ou outro destes dois métodos.</p>
<p>Em segundo lugar: quando rodei o código disponibilizado pelo gabarito notei que o tempo de execução foi gritantemente maior do que o tempo de execução do código que implementei. Rodei tudo de novo, dessa vez usando a biblioteca <em>time</em> para monitorar o tempo de execução dos dois métodos com precisão e fazer a comparação. Aqui, para não extender desenessariamente o texto, coloco como input os tempos calculados no meu notebook.</p>
<pre><code class="language-python">cosine_execution_time = 0.019317626953125
geopy_execution_time = 45.09127330780029

print(f&quot;O método do cosseno é {int(geopy_execution_time/cosine_execution_time)} mais rápido.&quot;)
</code></pre>
<p>O método do cosseno é 2334 mais rápido.</p>
<p>O método aproximado é milhares de vezes mais rápido! A solução do gabarito leva 45s para calcular as distâncias entre 249 cidades. Em uma aplicação real, não é difícil chegar em milhares ou milhões de pontos. Neste cenário, o ganho de eficiência demonstrado aqui seria ainda mais valioso.</p>
<p>Porém, antes de bater o martelo sobre qual seria o método mais adequado, é útil nos tornamos mais íntimos dos erros que estamos introduzindo nos dados. Assumimos no ínicio, com o argumento do achatamento desprezível, que os erros seriam pequenos. Agora, temos as distâncias calculadas tanto pelo método exato, quanto pela aproximação.</p>
<p>Vamos calcular os erros para cada par de capitais.</p>
<pre><code class="language-python"># Calcula os erros em Km e em termos de erro relativo (MAPE)
upper_triangle_indices = np.triu_indices_from(pairwise_distances, k=1)
pairwise_distances_flat = pairwise_distances[upper_triangle_indices]
geopy_pairwise_distances_flat = geopy_pairwise_distances[upper_triangle_indices]
error_km = np.abs(pairwise_distances_flat - geopy_pairwise_distances_flat)
error_relative = (error_km/geopy_pairwise_distances_flat)*100

print(f&quot;O método dos cossenos tem um erro médio de {np.round(np.mean(error_km),1)} Km ({np.round(np.mean(error_relative), 2)}%)&quot;)
</code></pre>
<p>O método dos cossenos tem um erro médio de 12.3 Km (0.17%)</p>
<p>E vamos ver como estes erros se distribuem.</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

plt.figure(figsize=(15, 15))
plt.subplot(2, 2, 1)
plt.hist(error_km, bins=40)
plt.xlabel('Error (Km)')
plt.ylabel('Frequency')
plt.title('Error distribution (Km)')

plt.subplot(2, 2, 2)
plt.hist(error_relative, bins=40)
plt.xlabel('Error (%)')
plt.ylabel('Frequency')
plt.title('Error distribution (relative)')

plt.subplot(2, 1, 2)
plt.boxplot(error_relative, vert=False, patch_artist=True, boxprops=dict(facecolor='orange'));
plt.ylabel('Percentual error (%)')
plt.title('Relative error boxplot')

plt.tight_layout()
plt.show()
</code></pre>
<img src="/2024/05/14/a-similaridade-de-cosseno-aproxima%C3%A7%C3%B5es-e-efic%C3%AAncia-de-c%C3%B3digo/index_files/figure-html/unnamed-chunk-9-1.png" width="1440" />
<p>Não me restam mais dúvidas. A aproximação esférica resulta em erros muito pequenos, praticamente desprezíveis. Quase 3/4 da distâncias apresentam menos 0.2% de erro. Nenhuma distância apresenta erro maior do que 35Km. E o método é mais de 2300x mais rápido. Em uma aplicação profissional, implementaria a aproximação esférica sem pensar duas vezes.</p>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
  


  </body>
</html>

