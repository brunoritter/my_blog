---
title: 'Probabilidades: uma solução analítica e uma simulação de Monte Carlo'
author: Bruno Ritter
date: '2024-05-27'
slug: atrasados
categories:
  - Data Science
tags:
  - probabilidade
  - data science
  - estatística
---

```{r setup, include=FALSE}
library(reticulate)
library(knitr)
use_condaenv("C:/Users/ritte/miniconda3/envs/my_blog")

knitr::opts_chunk$set(echo = TRUE, results = 'asis', message = FALSE, warning = FALSE)
```

Seguindo a jornada iniciada no primeiro post de resolver os desafios do data puzzles para tirar a poeira depois de alguns anos longe dos notebooks, neste post vamos explorar o desafio dos amigos atrasados.

O nome do desafio é right on time, e tem como pré requisitos conhecimentos em fundamentos de estatística, distribuições de probabilidade, e capacidade de programar pequenas simulações "na unha". Parece divertido.

O exercício é o seguinte: preciso marcar um compromisso com 4 amigos, e é importante que todos estejam presentes às 18h. Conhecendo meus amigos, sei que têm o hábito de se atrasar. Sei inclusive *como* - ou, ainda melhor, o *quanto* - eles costumam se atrasar. O tempo de chegada de cada um deles pode ser descrito como uma variável aleatória que segue uma distribuição normal, com média na hora marcada, e desvio padrão de 10 minutos. 

**Qual é o horário que devo marcar para ter 99% de confiança de que todos meus amigos estarão presentes às 18h?**

Eis a questão.

Primeiro, vamos entender o que as informações disponibilizadas significam. Sabemos que a média do tempo de chegada é o tempo marcado, ou seja, o *atraso médio* é $\mu = \mathbf{0} min$. E também sabemos *desvio padrão* do atraso médio é de $\sigma = 10  min$. 

Isso nos dá uma enorme previsibilidade sobre o comportamento dos nossos amigos, e já nos permite começar a fazer algumas simulações e visualizar nossas probabilidades.

Vamos começar simulando 150 encontros com um amigo, e em seguida montar um histograma dos atrasos nestes encontros.

```{python, include=TRUE}
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Usamos o numpy para obter 1000 amostras de uma distribuição de atrasos
np.random.seed(1568)
mu = 0  # atraso médio
sigma = 10  # desvio padrão
sims = 150 # define o número de simulações
atrasos = np.random.normal(loc=mu, scale=sigma, size=sims)

# Usamos o seaborn para plotar um histograma, com curva de densidade
sns.histplot(atrasos, kde=True, bins=30, color='orange')

# Configurando o título e os rótulos
plt.title('Histograma com Curva de Densidade')
plt.xlabel('Atraso (min)')
plt.ylabel('Frequência')

# Exibindo o gráfico
plt.show()

```

Aqui temos uma visão completa do que significam os parâmetros da distribuição. Percebemos que nosso amigo se atrasou com a mesma frequência que se adiantou. Embora na maior parte das vezes o atraso é próximo de 10min, em algumas situações eu tive de esperar mais de 30min.

Qual a probabilidade dele se atrasar? Podemos ver o registro das nossas simulações e calcular em qual proporção dos encontros ele se atrasou para obtermos uma estimativa.

```{python, include=TRUE}
contagem_atrasos = np.sum(atrasos > 0) 
p_atraso = contagem_atrasos/sims
print(f"Nosso amigo se atrasou em {contagem_atrasos} da simulações. Estimamos que a probabilidade de atraso é de {p_atraso*100}%")
```

E este, meus caros, foi o método de Monte Carlo em ação.

A simulação de Monte Carlo é uma técnica estatística que utiliza a geração de números aleatórios para realizar simulações de processos complexos e calcular probabilidades. É particularmente útil para estimar probabilidades e expectativas de sistemas onde a solução analítica é difícil ou impossível de obter.

Mas pera aí. Solução analítica difícil de obter?! Certamente não é o nosso caso.

Se a nossa variável aleatória pode ser modelada como uma distribuição normal, nós sabemos exatamente a forma da função de densidade de probabilidades (PDF), sem precisar de simulações!

$$
f(x | \mu, \sigma) = \frac{1}{\sqrt{2\pi\sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}
$$

Neste modelo, $\mathbf{f(x|\mu,\sigma)}$ dá a probabilidade de cada tempo de atraso específico $\mathbf{(x)}$ dados os parâmetros da distribuição $\mathbf{(\mu,\sigma)}$. 

Este modelo está implementado no `scipy.stats.norm.pdf`, e podemos usá-lo para visualizar as probabilidades:

```{python, include=TRUE}
from scipy.stats import norm

# Gerando valores para x (tempos de atraso)
x = np.linspace(mu - 4*sigma, mu + 4*sigma, 1000)

# Calculando a PDF
pdf_values = norm.pdf(x, loc=mu, scale=sigma)

# Plotando a PDF
plt.plot(x, pdf_values, label='PDF', color='blue')

# Configurando o título e os rótulos
plt.title('Função Densidade de Probabilidade dos Atrasos')
plt.xlabel('Tempo de atraso (min)')
plt.ylabel('Densidade de Probabilidade')
plt.legend()

# Exibindo o gráfico
plt.show()

```

Para encontrar a probabilidade de atraso analiticamente, precisamos somar todas probabilidades de atrasos maiores do que $\mathbf{0}$ minutos. Ou seja, precisamos integrar a PDF. A integral da PDF de uma distribuição é chamada de função de distribuição cumulativa (CDF). 