---
title: 'Probabilidades: uma solução analítica e uma simulação de Monte Carlo'
author: Bruno Ritter
date: '2024-05-27'
slug: atrasados
categories:
  - Data Science
tags:
  - probabilidade
  - data science
  - estatística
---

```{r setup, include=FALSE}
library(reticulate)
library(knitr)
use_condaenv("C:/Users/ritte/miniconda3/envs/my_blog")

knitr::opts_chunk$set(echo = TRUE, results = 'asis', message = FALSE, warning = FALSE)
```

Seguindo a jornada iniciada no primeiro post de resolver os desafios do data puzzles para tirar a poeira depois de alguns anos longe dos notebooks, neste post vamos explorar o desafio dos amigos atrasados.

O nome do desafio é right on time, e tem como pré requisitos conhecimentos em fundamentos de estatística, distribuições de probabilidade, e capacidade de programar pequenas simulações "na unha". Parece divertido.

O exercício é o seguinte: preciso marcar um compromisso com 4 amigos, e é importante que todos estejam presentes às 18h. Conhecendo meus amigos, sei que têm o hábito de se atrasar. Sei inclusive *como* - ou, ainda melhor, o *quanto* - eles costumam se atrasar. O tempo de chegada de cada um deles pode ser descrito como uma variável aleatória que segue uma distribuição normal, com média na hora marcada, e desvio padrão de 10 minutos. 

**Qual é o horário que devo marcar para ter 99% de confiança de que todos meus amigos estarão presentes às 18h?**

Eis a questão.

Primeiro, vamos entender o que as informações disponibilizadas significam. Sabemos que a média do tempo de chegada é o tempo marcado, ou seja, o *atraso médio* é $\mu = 0 min$. E também sabemos *desvio padrão* do atraso médio é de $\sigma = 10  min$. 

Isso nos dá uma enorme previsibilidade sobre o comportamento dos nossos amigos, e já nos permite começar a fazer algumas simulações e visualizar nossas probabilidades.

Vamos começar simulando 150 encontros com um amigo, e em seguida montar um histograma dos atrasos nestes encontros.

```{python, include=TRUE}
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# Usamos o numpy para obter 1000 amostras de uma distribuição de atrasos
np.random.seed(1568)
mu = 0  # atraso médio
sigma = 10  # desvio padrão
sims = 150 # define o número de simulações
atrasos = np.random.normal(loc=mu, scale=sigma, size=sims)

# Usamos o seaborn para plotar um histograma, com curva de densidade
sns.histplot(atrasos, kde=True, bins=30, color='orange')

# Configurando o título e os rótulos
plt.title('Histograma com Curva de Densidade')
plt.xlabel('Atraso (min)')
plt.ylabel('Frequência')

# Exibindo o gráfico
plt.show()

```

Aqui temos uma visão completa do que significam os parâmetros da distribuição. Percebemos que nosso amigo se atrasou mais ou menos com a mesma frequência que se adiantou. E que embora na maior parte das vezes o atraso foi próximo de 10min, em algumas situações eu tive que esperar mais de 30min.

Qual a probabilidade dele se atrasar? Podemos ver o registro das nossas simulações e calcular em qual proporção dos encontros ele se atrasou para obtermos uma estimativa.

```{python, include=TRUE}
contagem_atrasos = np.sum(atrasos > 0) 
p_atraso_sim = contagem_atrasos/sims
print(f"Nosso amigo se atrasou em {contagem_atrasos} da simulações. Estimamos que a probabilidade de atraso é de {p_atraso_sim*100}%")
```

E este, meus caros, foi o método de Monte Carlo em ação.

A simulação de Monte Carlo é uma técnica estatística que utiliza a geração de números aleatórios através de algum modelo matemático para realizar simulações de processos complexos e analisar a distribuição dos resultados. É particularmente útil para estimar probabilidades e expectativas de sistemas onde a solução analítica é difícil ou impossível de obter.

Mas pera aí. Solução analítica difícil de obter?! Certamente não é o nosso caso.

Se a nossa variável aleatória pode ser modelada como uma distribuição normal, nós sabemos exatamente a forma da função de densidade de probabilidades (PDF), sem precisar de simulações!

$$
f(x | \mu, \sigma) = \frac{1}{\sqrt{2\pi\sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}
$$

Neste modelo, $f(x|\mu,\sigma)$ dá a probabilidade de cada tempo de atraso específico $(x)$ dados os parâmetros da distribuição $(\mu,\sigma)$. 

Este modelo está implementado no `scipy.stats.norm.pdf`, e podemos usá-lo para visualizar as probabilidades:

```{python, include=TRUE}
from scipy.stats import norm

# Gerando valores para x (tempos de atraso)
x = np.linspace(mu - 4*sigma, mu + 4*sigma, 1000)

# Calculando a PDF
pdf_values = norm.pdf(x, loc=mu, scale=sigma)

# Plotando a PDF
plt.plot(x, pdf_values, label='PDF', color='blue')

# Configurando o título e os rótulos
plt.title('Função Densidade de Probabilidade dos Atrasos')
plt.xlabel('Tempo de atraso (min)')
plt.ylabel('Densidade de Probabilidade')
plt.legend()

# Exibindo o gráfico
plt.show()

```

Para encontrar a probabilidade de atraso analiticamente, precisamos somar todas probabilidades de atrasos maiores do que $\mathbf{0}$ minutos. Ou seja, precisamos integrar a PDF. A integral da PDF de uma distribuição é chamada de função de distribuição cumulativa (CDF). Mais especificamente, é uma integral de menos infinito até algum valor de $\mathbf{x}$. Podemos escrever ela assim:

$$
F(x) = P(X \leq x) = \int_{-\infty}^{x} f(t) \, dt
$$
Onde:

  * $F(x)$ é a função de distribuição cumulativa (CDF), que representa a probabilidade acumulada até o ponto $x$.
  * $P(X \leq x)$ é a probabilidade de que a variável aleatória $X$ seja menor ou igual a $x$.
  * $f(t)$ é a função densidade de probabilidade (PDF) da variável aleatória X.
  * $t$ é a variável de integração.

Na prática, isso significa que a CDF nos responde à pergunta: 

"*qual a probabilidade do atraso ser __igual__ ou __menor__ do que $\mathbf{x}$ min?*"

E podemos usar isso para saber a probabilidade de atraso. A CDF também está implementada no `scipy`:

```{python, include=TRUE}
# Calculando a CDF com F(x=0)
x = 0
cdf_x = norm.cdf(x, loc=mu, scale=sigma) # norm foi importado no bloco anterior

# Calculando a probabilidade P(X>0) = 1-F(x=0)
p_atraso_cdf = 1-cdf_x
print(f"A probabilidade do nosso amigo atrasar é de {p_atraso_cdf*100}%")
```

Embora a simulação de Monte Carlo seja poderosa para estimar probabilidades em sistemas complexos, ela depende de um grande número de amostras para se aproximar do valor real. No nosso exemplo, a estimativa de 44% com Monte Carlo contrasta com os 50% obtidos analiticamente. Isso mostra que Monte Carlo precisa de mais simulações para alcançar precisão comparável aos métodos analíticos, que são exatos mas nem sempre disponíveis. Portanto, a escolha entre os métodos deve considerar a complexidade do problema e a necessidade de precisão.